<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚¸ãƒ£ãƒ³ãƒ—ã‚²ãƒ¼ãƒ </title>
    <linkpreconnect href="https://fonts.googleapis.com">
        <linkpreconnect href="https://fonts.gstatic.com" crossorigin>
            <link href="https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&display=swap" rel="stylesheet">
            <style>
                :root {
                    --color-bg-dark: #121418;
                    --color-bg-light: #1c2229;
                    --color-accent: #ff5459;
                    /* èµ¤ */
                    --color-accent-hover: #ff767a;
                    --color-gold: #ffd700;
                    --font-game: 'Mochiy Pop One', sans-serif;
                    --font-base: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                }

                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }

                body {
                    font-family: var(--font-base);
                    /* èƒŒæ™¯ç”»åƒã®è¨­å®š */
                    background-image: url('background.png');
                    background-repeat: no-repeat;
                    background-size: cover;
                    background-position: center;
                    background-attachment: fixed;
                    image-rendering: pixelated;

                    color: #f0f0f0;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    min-height: 100vh;
                    padding: 40px 20px;
                }

                .char-card {
                    position: relative;
                    /* ãƒãƒ–ãƒ«é…ç½®ç”¨ */
                    border: 2px solid #ff5459;
                    /* å¸¸ã«èµ¤æ  */
                    border-radius: 12px;
                    padding: 15px;
                    text-align: center;
                    width: 250px;
                    /* æ¨ªå¹…ã‚’åºƒã’ã¦èª¬æ˜æ–‡ã«å¯¾å¿œ */
                    cursor: pointer;
                    background: #000;
                    /* èƒŒæ™¯é»’ */
                    transition: transform 0.2s;
                    color: white;
                    /* ãƒ†ã‚­ã‚¹ãƒˆç™½ */
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    margin-top: 40px;
                    /* ãƒãƒ–ãƒ«ã®ã‚¹ãƒšãƒ¼ã‚¹ç¢ºä¿ */
                }

                .speech-bubble {
                    position: absolute;
                    top: -50px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #fff;
                    color: #000;
                    padding: 8px 12px;
                    border-radius: 20px;
                    font-size: 13px;
                    font-weight: bold;
                    white-space: nowrap;
                    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
                    z-index: 10;
                }

                .speech-bubble::after {
                    content: '';
                    position: absolute;
                    bottom: -8px;
                    left: 50%;
                    transform: translateX(-50%);
                    border-width: 8px 8px 0;
                    border-style: solid;
                    border-color: #fff transparent;
                }

                .char-desc {
                    font-size: 12px;
                    text-align: left;
                    margin-top: 10px;
                    line-height: 1.4;
                    width: 100%;
                }

                .difficulty {
                    color: #FFD700;
                    /* é‡‘è‰² */
                    font-weight: bold;
                    margin-bottom: 5px;
                    text-align: center;
                    width: 100%;
                }

                .container {
                    max-width: 860px;
                    width: 100%;
                    text-align: center;
                }

                /* ã‚²ãƒ¼ãƒ ç”»é¢ã®æ ãƒ‡ã‚¶ã‚¤ãƒ³ */
                .game-wrapper {
                    position: relative;
                    padding: 10px;
                    background: rgba(0, 0, 0, 0.3);
                    border-radius: 20px;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                    margin-bottom: 30px;
                }

                #gameCanvas {
                    border: 4px solid #2a2a2a;
                    border-radius: 12px;
                    background: #000;
                    box-shadow: 0 0 20px rgba(255, 84, 89, 0.2);
                    width: 100%;
                    max-width: 800px;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    touch-action: none;
                    cursor: pointer;
                }

                /* æ“ä½œãƒ‘ãƒãƒ«ã‚¨ãƒªã‚¢ */
                .controls {
                    display: flex;
                    gap: 15px;
                    justify-content: center;
                    flex-wrap: wrap;
                    margin-bottom: 30px;
                    padding: 20px;
                    background: rgba(255, 255, 255, 0.05);
                    border-radius: 16px;
                    backdrop-filter: blur(5px);

                    /* åˆæœŸçŠ¶æ…‹ã¯éè¡¨ç¤ºï¼ˆJSã§åˆ¶å¾¡ï¼‰ */
                    opacity: 0;
                    pointer-events: none;
                    transition: opacity 0.5s ease;
                }

                /* ã‚²ãƒ¼ãƒ é–‹å§‹å¾Œã«è¡¨ç¤ºã™ã‚‹ãŸã‚ã®ã‚¯ãƒ©ã‚¹ */
                .controls.active {
                    opacity: 1;
                    pointer-events: auto;
                }

                /* ãƒœã‚¿ãƒ³ã®ãƒ‡ã‚¶ã‚¤ãƒ³ */
                .btn {
                    font-family: var(--font-game);
                    padding: 12px 24px;
                    font-size: 1rem;
                    border: 2px solid #ffffff;
                    border-radius: 6px;
                    cursor: pointer;
                    transition: all 0.1s ease;
                    box-shadow: 0 4px 0 #444444;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                }

                .btn:active {
                    transform: translateY(4px);
                    box-shadow: none;
                }

                .btn-primary {
                    background: #000000;
                    color: #ffffff;
                    text-shadow: none;
                }

                .btn-primary:hover:not(:disabled) {
                    background: #333333;
                    transform: translateY(-2px);
                    box-shadow: 0 6px 0 #444444;
                    border-color: #cccccc;
                }

                .btn:disabled {
                    background: #222222;
                    border-color: #555555;
                    color: #555555;
                    cursor: not-allowed;
                    transform: none;
                    box-shadow: none;
                }

                /* èª¬æ˜ã‚¨ãƒªã‚¢ */
                .instructions {
                    text-align: left;
                    background: rgba(0, 0, 0, 0.4);
                    padding: 20px 30px;
                    border-radius: 12px;
                    border-left: 5px solid var(--color-accent);
                    font-size: 0.95rem;
                    line-height: 1.8;
                    color: #ccc;
                    max-width: 700px;
                    margin: 0 auto;
                }

                .instructions strong {
                    color: #fff;
                    font-family: var(--font-game);
                }

                /* ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç³»ï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ãªã©ï¼‰ */
                .game-over {
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(20, 20, 20, 0.95);
                    padding: 40px;
                    border-radius: 20px;
                    border: 4px solid var(--color-accent);
                    text-align: center;
                    display: none;
                    box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
                    z-index: 20;
                    width: 80%;
                    max-width: 400px;
                }

                .game-over.show {
                    display: block;
                    animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                }

                .game-over h2 {
                    font-family: var(--font-game);
                    color: var(--color-accent);
                    margin-bottom: 20px;
                }

                .game-over p {
                    font-size: 1.2rem;
                    margin-bottom: 25px;
                    font-weight: bold;
                }

                @keyframes popIn {
                    from {
                        transform: translate(-50%, -50%) scale(0.5);
                        opacity: 0;
                    }

                    to {
                        transform: translate(-50%, -50%) scale(1);
                        opacity: 1;
                    }
                }

                /* ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼é¸æŠãƒ»ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãªã©ã®ãƒ‘ãƒãƒ« */
                #charSelectScreen,
                #rankingScreen {
                    background: #222;
                    border: 2px solid #444;
                    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                    max-width: 800px;
                    margin: 20px auto;
                }

                /* ã‚¹ãƒãƒ›å¯¾å¿œ */
                @media (max-width: 600px) {
                    h1 {
                        font-size: 1.5rem;
                    }

                    .btn {
                        padding: 10px 20px;
                        font-size: 0.9rem;
                    }

                    .controls {
                        padding: 10px;
                    }

                    body {
                        padding: 20px 10px;
                    }
                }
            </style>
</head>

<body>
    <div class="container">
        <div class="game-wrapper">
            <canvas id="gameCanvas" width="800" height="400"></canvas>

            <div style="display: none;">
                <span id="score">0</span>
                <span id="lives">3</span>
                <span id="highScore">0</span>
            </div>

            <div id="gameOverScreen" class="game-over">
                <h2>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
                <p id="finalScore">ã‚¹ã‚³ã‚¢: 0</p>
                <p id="newRecord" style="color: #4cd137; display: none;">ğŸ‰ æ–°è¨˜éŒ²!</p>
                <button class="btn btn-primary" onclick="restartGame()">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
            </div>
        </div>

        <div id="controlsPanel" class="controls">
            <button id="pauseBtn" class="btn btn-primary" onclick="togglePause()">ä¸€æ™‚åœæ­¢</button>
            <button id="charSelectBtn" class="btn btn-primary" onclick="toggleCharSelect()">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼</button>
            <button id="rankingBtn" class="btn btn-primary" onclick="toggleRanking()">ã‚¹ã‚³ã‚¢ã®è¨˜éŒ²</button>
        </div>

        <div id="charSelectScreen" style="display: none; margin-top: 20px; padding: 20px;">
            <h2 style="color: var(--color-accent); margin-bottom: 15px;">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼é¸æŠ</h2>
            <div id="characterGrid" style="display: flex; gap: 20px; justify-content: center;">
                <!-- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼1 (æ‰¿èªæ¬²æ±‚ãã‚“) -->
                <div class="char-card" onclick="selectCharacter(0)">
                    <div class="speech-bubble">é ‘å¼µã£ãŸã‚‰ã€ã”é£¯å¥¢ã£ã¦ãã‚Œã‚‹ï¼Ÿ</div>
                    <div style="font-weight: bold; margin-bottom: 5px; color: white; font-size: 18px;">æ‰¿èªæ¬²æ±‚ãã‚“</div>
                    <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 5px;">
                        <img src="s_walk1.png" style="height: 60px; width: auto; image-rendering: pixelated;">
                    </div>
                    <div class="difficulty">é›£æ˜“åº¦ï¼šâ˜…â˜†â˜†</div>
                    <div class="char-desc">
                        ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ã‚¸ãƒ£ãƒ³ãƒ—ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆï¼<br>
                        ï¼’å›ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ï¼’æ®µéšã‚¸ãƒ£ãƒ³ãƒ—ãŒå¯èƒ½ï¼
                    </div>
                </div>
                <!-- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼2 (å®Ÿç¾æ¬²æ±‚ãã‚“) -->
                <div class="char-card" onclick="selectCharacter(1)">
                    <div class="speech-bubble">æ—©ãå¸°ã£ã¦ãŠçµµæãã—ãŸã„ã‚ˆ...</div>
                    <div style="font-weight: bold; margin-bottom: 5px; color: white; font-size: 18px;">å®Ÿç¾æ¬²æ±‚ãã‚“</div>
                    <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 5px;">
                        <img src="z_walk1.png" style="height: 60px; width: auto; image-rendering: pixelated;">
                    </div>
                    <div class="difficulty">é›£æ˜“åº¦ï¼šâ˜…â˜…â˜…</div>
                    <div class="char-desc">
                        ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨æ•°ç§’ã ã‘åœ°é¢ã®ä¸‹ã‚’æ½œã‚Œã‚‹ã‚ˆï¼<br>
                        ï¼’å›ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨é£›ã³å‡ºã—ã¦ã‚¸ãƒ£ãƒ³ãƒ—ã™ã‚‹ï¼<br>
                        <span style="color: #ff5459;">éšœå®³ç‰©ã®ä¸‹ã‹ã‚‰é£›ã³å‡ºãã†ã¨ã™ã‚‹ã¨ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ãã‚‰ã£ã¡ã‚ƒã†ã‚ˆï¼</span>
                    </div>
                </div>
            </div>
            <button class="btn btn-primary" onclick="toggleCharSelect()" style="margin-top: 15px;">é–‰ã˜ã‚‹</button>
        </div>

        <div id="rankingScreen"
            style="display: none; margin-top: 20px; padding: 20px; background: #2c2c2c; border-radius: 12px; color: #fff;">
            <h2 style="color: var(--color-accent); margin-bottom: 15px;">ã‚¹ã‚³ã‚¢ã®è¨˜éŒ²</h2>
            <div id="rankingList" style="text-align: left; max-width: 400px; margin: 0 auto;">
            </div>
            <button class="btn btn-primary" onclick="toggleRanking()" style="margin-top: 15px;">é–‰ã˜ã‚‹</button>
        </div>

        <div class="instructions">
            <strong>æ“ä½œæ–¹æ³•:</strong> ã‚¯ãƒªãƒƒã‚¯ã€ã‚¿ãƒƒãƒ—ã€ã¾ãŸã¯ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ã‚¸ãƒ£ãƒ³ãƒ—! ç©ºä¸­ã§ã‚‚ã†ä¸€åº¦æŠ¼ã™ã¨äºŒæ®µã‚¸ãƒ£ãƒ³ãƒ—!<br>
            éšœå®³ç‰©ã«å½“ãŸã‚‰ãªã„ã‚ˆã†ã«é¿ã‘ã¦ã€ã§ãã‚‹ã ã‘é•·ãèµ°ã‚Šç¶šã‘ã‚ˆã†!
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const livesElement = document.getElementById('lives');
        const pauseBtn = document.getElementById('pauseBtn');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreElement = document.getElementById('finalScore');
        const newRecordElement = document.getElementById('newRecord');
        const controlsPanel = document.getElementById('controlsPanel');

        // â˜…ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ç®¡ç†
        let gameState = 'TITLE';

        // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”»åƒã®èª­ã¿è¾¼ã¿ç®¡ç†
        let currentCharacterId = 0; // 0: æ‰¿èªæ¬²æ±‚ãã‚“, 1: å®Ÿç¾æ¬²æ±‚ãã‚“
        const characterAssets = [
            // Char 0: æ‰¿èªæ¬²æ±‚ãã‚“ (s_ prefix)
            {
                walk: [], jump: [], dmgWalk: [], dmgJump: []
            },
            // Char 1: å®Ÿç¾æ¬²æ±‚ãã‚“ (z_ prefix)
            {
                walk: [], jump: [], dmgWalk: [], dmgJump: [], swim: [] // swim added
            }
        ];

        // ç¢ºå®Ÿãªå€‹åˆ¥æŒ‡å®šã§èª­ã¿è¾¼ã¿
        // Char 0: æ‰¿èªæ¬²æ±‚ãã‚“
        const c0 = characterAssets[0];
        ['s_walk1.png', 's_walk2.png', 's_walk3.png', 's_walk4.png'].forEach(u => { const i = new Image(); i.src = u; c0.walk.push(i); });
        ['s_janp1.png', 's_janp2.png'].forEach(u => { const i = new Image(); i.src = u; c0.jump.push(i); });
        ['s_d_walk1.png', 's_d_walk2.png', 's_d_walk3.png', 's_d_walk4.png'].forEach(u => { const i = new Image(); i.src = u; c0.dmgWalk.push(i); });
        ['s_d_janp1.png', 's_d_janp2.png'].forEach(u => { const i = new Image(); i.src = u; c0.dmgJump.push(i); });

        // Char 1: å®Ÿç¾æ¬²æ±‚ãã‚“
        const c1 = characterAssets[1];
        ['z_walk1.png', 'z_walk2.png', 'z_walk3.png', 'z_walk4.png'].forEach(u => { const i = new Image(); i.src = u; c1.walk.push(i); });
        // Jump: 4æšèª­ã¿è¾¼ã‚€ (å‰åŠ2æš:ä¸Šæ˜‡, å¾ŒåŠ2æš:ä¸‹é™/ç€åœ°)
        ['z_janp1.png', 'z_janp2.png', 'z_janp3.png', 'z_janp4.png'].forEach(u => { const i = new Image(); i.src = u; c1.jump.push(i); });
        ['z_d_walk1.png', 'z_d_walk2.png', 'z_d_walk3.png', 'z_d_walk4.png'].forEach(u => { const i = new Image(); i.src = u; c1.dmgWalk.push(i); });
        // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¸ãƒ£ãƒ³ãƒ—ã‚‚åŒæ§˜ã«4æšèª­ã¿è¾¼ã‚€ (ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèªæ¸ˆã¿)
        ['z_d_janp1.png', 'z_d_janp2.png', 'z_d_janp3.png', 'z_d_janp4.png'].forEach(u => { const i = new Image(); i.src = u; c1.dmgJump.push(i); });
        // Swim
        ['z_swim1.png', 'z_swim2.png', 'z_swim3.png', 'z_swim4.png'].forEach(u => { const i = new Image(); i.src = u; c1.swim.push(i); });
        // èƒŒæ™¯ãƒ»éšœå®³ç‰©ãƒ»ã‚¢ã‚¤ãƒ†ãƒ 
        const bgSkyImg = new Image(); bgSkyImg.src = 'bg_sky.png';
        const bgGroundImg = new Image(); bgGroundImg.src = 'bg_ground.png';
        const obstacle1Img = new Image(); obstacle1Img.src = 'obstacle_1.png';
        const obstacle2Img = new Image(); obstacle2Img.src = 'obstacle_2.png';
        const bird1Img = new Image(); bird1Img.src = 'bird_1.png';
        const bird2Img = new Image(); bird2Img.src = 'bird_2.png';
        const coinImg = new Image(); coinImg.src = 'coin.png';
        const heartItemImg = new Image(); heartItemImg.src = 'heart_item.png';

        // ã‚³ã‚¤ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        const coinImgs = [];
        for (let i = 1; i <= 4; i++) {
            const img = new Image();
            img.src = `coin_${i}.png`;
            coinImgs.push(img);
        }

        // å¤‰æ•°å®šç¾©
        let bgGroundOffset = 0;
        let bgSkyOffset = 0;
        let gamePaused = false;

        let score = 0;
        let lives = 3;
        let highScore = parseInt(localStorage.getItem('jumpGameHighScore') || '0');
        let gameSpeed = 3;
        let frameCount = 0;

        // ã‚¹ãƒ¼ãƒ‘ãƒ¼ç„¡æ•µãƒ¢ãƒ¼ãƒ‰ç”¨
        let comboCoins = 0;
        let isSuperMode = false;
        let superModeTimer = 0;
        let baseSpeed = 0;

        highScoreElement.textContent = highScore;

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å®šç¾©
        const player = {
            x: 250,
            y: canvas.height - 95, // Adjusted for character height
            width: 50,
            height: 64,
            dy: 0,
            jumpPower: -10,
            doubleJumpPower: -7,
            gravity: 0.35,
            isJumping: false,
            canDoubleJump: false,
            groundY: canvas.height - 95,
            isDiving: false, // æ½œã‚ŠçŠ¶æ…‹
            diveTimer: 0     // æ½œã‚Šæ™‚é–“
        };

        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…åˆ—
        const obstacles = [];
        const coins = [];
        const hearts = [];
        const flyingObstacles = [];
        const clouds = [];

        // ã‚¿ã‚¤ãƒãƒ¼ç³»
        let obstacleTimer = 0;
        let nextObstacleInterval = 100;
        let coinTimer = 0;
        let heartTimer = 0;
        let flyingObstacleTimer = 0;
        let invincibleTimer = 0;

        // åˆæœŸé›²ç”Ÿæˆ
        for (let i = 0; i < 5; i++) {
            clouds.push({
                x: Math.random() * canvas.width,
                y: Math.random() * 100 + 20,
                width: 60 + Math.random() * 40,
                speed: 0.5 + Math.random() * 0.5
            });
        }

        // éšœå®³ç‰©é€£ç¶šå‡ºç¾ç®¡ç†ç”¨
        let lastObstacleType = null; // 'small' or 'tall'
        let consecutiveCount = 0;

        // ã‚¸ãƒ£ãƒ³ãƒ—å…¥åŠ›ç®¡ç†
        let jumpPressed = false;

        function handleInput(e) {
            if (gameState === 'TITLE') {
                startGame();
                return;
            }
            if (gameState === 'GAMEOVER') return;
            if (gameState === 'PLAYING' && !gamePaused) {
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼1 (å®Ÿç¾æ¬²æ±‚ãã‚“) ã®å‡¦ç†: ã‚¿ãƒƒãƒ—/ã‚¯ãƒªãƒƒã‚¯ã§ã€Œæ½œã‚‹ã€
                if (currentCharacterId === 1) {
                    if (!player.isJumping && !player.isDiving) {
                        // åœ°é¢ã«ã„ã¦æ½œã£ã¦ã„ãªã„æ™‚ -> æ½œã‚‹
                        if (characterAssets[1].swim.length > 0) {
                            player.isDiving = true;
                            player.diveTimer = 60; // å»¶é•· (ç´„1ç§’)
                        }
                    } else if (player.isDiving) {
                        // æ½œã£ã¦ã„ã‚‹æ™‚ã«ã‚¯ãƒªãƒƒã‚¯ -> ã‚¸ãƒ£ãƒ³ãƒ—ï¼ (å®‰å…¨ç¢ºèªãªã—ï¼ã‚¿ã‚¤ãƒŸãƒ³ã‚°é‡è¦)
                        player.isDiving = false;
                        player.dy = player.jumpPower;
                        player.isJumping = true;
                        player.canDoubleJump = true;
                        player.y = player.groundY;
                    }
                }
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼0 (é€šå¸¸) ã®å‡¦ç†
                else {
                    if (!jumpPressed) {
                        if (!player.isJumping) {
                            player.dy = player.jumpPower;
                            player.isJumping = true;
                            player.canDoubleJump = true;
                            jumpPressed = true;
                        } else if (player.canDoubleJump) {
                            player.dy = player.doubleJumpPower;
                            player.canDoubleJump = false;
                            jumpPressed = true;
                        }
                    }
                }
            }
        }

        canvas.addEventListener('mousedown', handleInput);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput(e);
        }, { passive: false });
        canvas.addEventListener('mouseup', () => { jumpPressed = false; });
        canvas.addEventListener('touchend', () => { jumpPressed = false; });
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (!jumpPressed) handleInput(e);
            }
            if (e.code === 'ArrowDown') {
                // ArrowDownã§ã®å€‹åˆ¥Diveæ©Ÿèƒ½ã¯å‰Šé™¤(çµ±åˆã•ã‚ŒãŸãŸã‚)
            }
        });
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') jumpPressed = false;
        });

        // UIåˆ¶å¾¡é–¢æ•°
        function toggleCharSelect() {
            const screen = document.getElementById('charSelectScreen');
            const btn = document.getElementById('charSelectBtn');
            if (screen.style.display === 'none') {
                screen.style.display = 'block';
                btn.textContent = 'é–‰ã˜ã‚‹';
                gamePaused = true;
            } else {
                screen.style.display = 'none';
                btn.textContent = 'ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼';
                if (gameState === 'PLAYING') gamePaused = false;
            }
        }

        function selectCharacter(id) {
            currentCharacterId = id;
            // UIæ›´æ–°
            updateCharSelectUI(id);
            // é¸æŠã—ãŸã‚‰è‡ªå‹•ã§é–‰ã˜ã‚‹
            toggleCharSelect();
        }

        function updateCharSelectUI(id) {
            // Main Menu Cards
            const cards = document.querySelectorAll('.char-card');
            cards.forEach((card, index) => {
                if (index === id) {
                    // é¸æŠä¸­ã¯å°‘ã—æ˜ã‚‹ãã™ã‚‹ã‹ã€ãã®ã¾ã¾ã«ã™ã‚‹ã‹ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼è¦æœ›ã¯ã€Œæ ã¯ä¸¡æ–¹ã¨ã‚‚èµ¤ã€
                    // é¸æŠçŠ¶æ…‹ã‚’ç¤ºã™ãŸã‚ã«èƒŒæ™¯ã‚’å°‘ã—å¤‰ãˆã‚‹ç­‰ã¯æ®‹ã™ãŒã€åŸºæœ¬ã¯é»’
                    card.style.backgroundColor = '#333';
                } else {
                    card.style.backgroundColor = '#000';
                }
                // æ ã¯CSSã§èµ¤ã«å›ºå®šã—ãŸãŒã€ã“ã“ã§ã®ä¸Šæ›¸ãã«æ³¨æ„
                card.style.borderColor = '#ff5459';
            });
        }

        function toggleRanking() {
            const screen = document.getElementById('rankingScreen');
            const btn = document.getElementById('rankingBtn');
            if (screen.style.display === 'none') {
                screen.style.display = 'block';
                btn.textContent = 'é–‰ã˜ã‚‹';
                gamePaused = true;
                displayRanking(); // ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤ºé–¢æ•°ã‚’å‘¼ã³å‡ºã™
            } else {
                screen.style.display = 'none';
                btn.textContent = 'ãƒ©ãƒ³ã‚­ãƒ³ã‚°';
                if (gameState === 'PLAYING') gamePaused = false;
            }
        }

        function drawGround() {
            if (bgSkyImg.complete) {
                const skyScale = canvas.height / bgSkyImg.height;
                const skyScaledWidth = Math.ceil(bgSkyImg.width * skyScale);
                const drawX = Math.floor(bgSkyOffset);
                ctx.drawImage(bgSkyImg, drawX, 0, skyScaledWidth, canvas.height);
                ctx.drawImage(bgSkyImg, drawX + skyScaledWidth, 0, skyScaledWidth, canvas.height);
                ctx.drawImage(bgSkyImg, drawX + skyScaledWidth * 2, 0, skyScaledWidth, canvas.height);
            }
            if (bgGroundImg.complete) {
                const scale = canvas.height / bgGroundImg.height;
                const scaledWidth = Math.ceil(bgGroundImg.width * scale);
                const drawX = Math.floor(bgGroundOffset);
                ctx.drawImage(bgGroundImg, drawX, 0, scaledWidth, canvas.height);
                ctx.drawImage(bgGroundImg, drawX + scaledWidth, 0, scaledWidth, canvas.height);
                ctx.drawImage(bgGroundImg, drawX + scaledWidth * 2, 0, scaledWidth, canvas.height);
            }
        }

        function drawClouds() {
            ctx.fillStyle = 'rgba(167, 169, 169, 0.3)';
            clouds.forEach(cloud => {
                ctx.beginPath();
                ctx.ellipse(cloud.x, cloud.y, cloud.width / 2, 20, 0, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawPlayer() {
            const isDamage = invincibleTimer > 0;
            const shouldShowDamage = isDamage && Math.floor(frameCount / 6) % 2 === 0;

            // ç¾åœ¨ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ã‚¢ã‚»ãƒƒãƒˆã‚’å–å¾—
            const currentAssets = characterAssets[currentCharacterId];
            if (!currentAssets) return;

            let img;
            // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ID 0 (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ) ã®å ´åˆ: ç”»åƒæç”»
            if (currentCharacterId === 0) {
                if (player.isJumping) {
                    const jIdx = player.canDoubleJump ? 0 : 1;
                    img = shouldShowDamage ? currentAssets.dmgJump[jIdx] : currentAssets.jump[jIdx];
                } else {
                    const animIdx = Math.floor(frameCount / 8) % 4;
                    img = shouldShowDamage ? currentAssets.dmgWalk[animIdx] : currentAssets.walk[animIdx];
                }

                if (img && img.complete) {
                    ctx.drawImage(img, player.x, player.y, 50, 64);
                }
            }
            // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ID 1 (å®Ÿç¾æ¬²æ±‚ãã‚“)
            else if (currentCharacterId === 1) {
                if (player.isDiving) {
                    // æ½œã‚Šä¸­ã¯åŠé€æ˜ã«ã—ã¦ã€Œéš ã‚Œã¦ã‚‹æ„Ÿã€ã‚’å‡ºã™
                    ctx.save();
                    ctx.globalAlpha = 0.6;

                    // æ½œã‚Šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    const animIdx = Math.floor(frameCount / 6) % 4;
                    // z_swim1~4 ã‚’ãƒ«ãƒ¼ãƒ—
                    if (currentAssets.swim.length > animIdx) {
                        img = currentAssets.swim[animIdx];
                        if (img && img.complete) {
                            // é€šå¸¸åº§æ¨™ã§æç”» (æ²ˆã¾ã›ãªã„)
                            ctx.drawImage(img, player.x, player.y, 50, 64);
                        }
                    }
                    ctx.restore();
                } else if (player.isJumping) {
                    // ã‚¸ãƒ£ãƒ³ãƒ—: 1ã‹ã‚‰4ã¾ã§ã‚†ã£ãã‚Šä½¿ã† (ãƒ«ãƒ¼ãƒ—ã•ã›ãªã„)
                    // ã‚¸ãƒ£ãƒ³ãƒ—ãƒ‘ãƒ¯ãƒ¼ -10 -> 0 -> +è½ä¸‹é€Ÿåº¦
                    // dyã‚’ç›®å®‰ã«ã™ã‚‹
                    // -10 ... -5 ... 0 ... 5 ...
                    // 4æšã‚ã‚‹ã®ã§ã€
                    // 1æšç›®: é£›ã³ä¸ŠãŒã‚Šå§‹ã‚ (dy < -6)
                    // 2æšç›®: ä¸Šæ˜‡ä¸­ã€œé ‚ç‚¹æ‰‹å‰ (dy < -2)
                    // 3æšç›®: é ‚ç‚¹ä»˜è¿‘ã€œé™ä¸‹é–‹å§‹ (dy < 4)
                    // 4æšç›®: é™ä¸‹å¾ŒåŠ (dy >= 4)

                    let jIdx = 0;
                    if (player.dy < -6) jIdx = 0;
                    else if (player.dy < -2) jIdx = 1;
                    else if (player.dy < 4) jIdx = 2;
                    else jIdx = 3;

                    if (currentAssets.jump.length > jIdx) {
                        img = shouldShowDamage ? currentAssets.dmgJump[jIdx] : currentAssets.jump[jIdx];
                    } else if (currentAssets.jump.length > 0) {
                        img = currentAssets.jump[0];
                    }

                    if (img && img.complete) {
                        ctx.drawImage(img, player.x, player.y, 50, 64);
                    }
                } else {
                    // é€šå¸¸æ­©è¡Œ
                    const animIdx = Math.floor(frameCount / 8) % 4;
                    if (currentAssets.walk.length > animIdx) {
                        img = shouldShowDamage ? currentAssets.dmgWalk[animIdx] : currentAssets.walk[animIdx];
                    }
                    if (img && img.complete) {
                        ctx.drawImage(img, player.x, player.y, 50, 64);
                    }
                }

                // ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ (å…±é€š)
                if (isSuperMode) {
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(player.x + 25, player.y + 32, 40, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ (ç”»åƒãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ãªã„å ´åˆãªã©)
            if (!img || !img.complete) {
                ctx.fillStyle = (currentCharacterId === 1) ? '#ff5459' : '#fff';
                ctx.fillRect(player.x, player.y, 50, 64);
            }
        }

        function drawUI() {
            ctx.save();
            ctx.font = "bold 20px 'Mochiy Pop One', sans-serif";
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 0;
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#000000';
            ctx.fillStyle = '#ffffff';

            ctx.textAlign = 'right';
            ctx.strokeText(`SCORE: ${score}`, canvas.width - 20, 35);
            ctx.fillText(`SCORE: ${score}`, canvas.width - 20, 35);

            ctx.font = "bold 16px 'Mochiy Pop One', sans-serif";
            ctx.fillStyle = '#e68161';
            ctx.strokeText(`HI: ${highScore}`, canvas.width - 20, 60);
            ctx.fillText(`HI: ${highScore}`, canvas.width - 20, 60);

            ctx.textAlign = 'left';
            for (let i = 0; i < 3; i++) {
                const x = 20 + i * 40;
                const y = 15;
                if (i < lives) {
                    if (heartItemImg.complete) ctx.drawImage(heartItemImg, x, y, 30, 25);
                    else ctx.fillText('â™¥', x, y + 20);
                } else {
                    ctx.globalAlpha = 0.3;
                    if (heartItemImg.complete) ctx.drawImage(heartItemImg, x, y, 30, 25);
                    ctx.globalAlpha = 1.0;
                }
            }

            if (isSuperMode) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(20, canvas.height - 45, 200, 25);
                const barWidth = 200 * (superModeTimer / 600);
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(20, canvas.height - 45, barWidth, 25);
                ctx.fillStyle = '#ffffff';
                ctx.font = "bold 16px 'Mochiy Pop One', sans-serif";
                ctx.strokeText("SUPER MODE!", 30, canvas.height - 27);
                ctx.fillText("SUPER MODE!", 30, canvas.height - 27);
            } else {
                ctx.fillStyle = '#ffffff';
                ctx.font = "bold 16px 'Mochiy Pop One', sans-serif";
                ctx.strokeText("GET 5 COINS!", 20, canvas.height - 55);
                ctx.fillText("GET 5 COINS!", 20, canvas.height - 55);
                for (let i = 0; i < 5; i++) {
                    const x = 20 + i * 40;
                    const y = canvas.height - 45;
                    ctx.beginPath();
                    ctx.arc(x + 15, y + 15, 18, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fill();
                    if (i < comboCoins) {
                        if (coinImgs[0] && coinImgs[0].complete) {
                            ctx.drawImage(coinImgs[0], x, y, 30, 30);
                        } else if (coinImg.complete) {
                            ctx.drawImage(coinImg, x, y, 30, 30);
                        }
                    }
                }
            }
            ctx.restore();
        }

        function drawTitleScreen() {
            updateBackground();
            updateClouds();
            drawGround();
            drawClouds();

            player.x = 250;
            player.y = player.groundY;
            player.isJumping = false;
            frameCount++;
            drawPlayer();

            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.textAlign = 'center';
            ctx.font = "bold 60px 'Mochiy Pop One', sans-serif";
            ctx.lineWidth = 8;
            ctx.strokeStyle = '#000000';
            ctx.strokeText("JUMP GAME", canvas.width / 2, canvas.height / 2 - 20);
            ctx.fillStyle = '#ff5459';
            ctx.fillText("JUMP GAME", canvas.width / 2, canvas.height / 2 - 40);

            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«ã‚’è¡¨ç¤º (ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã§ã‚‚æ“ä½œå¯èƒ½ã«)
            controlsPanel.classList.add('active');
            // Ranking/CharSelectã ã‘æœ‰åŠ¹åŒ–ã—ãŸã„ãŒã€Pauseã¯ç„¡åŠ¹åŒ–ã™ã‚‹ã‹ï¼Ÿ
            // ä¸€æ—¦å…¨éƒ¨è¡¨ç¤ºã§OK

            if (Math.floor(frameCount / 30) % 2 === 0) {
                ctx.font = "bold 30px 'Mochiy Pop One', sans-serif";
                ctx.lineWidth = 4;
                ctx.strokeText("- CLICK TO START -", canvas.width / 2, canvas.height / 2 + 50);
                ctx.fillStyle = '#ffffff';
                ctx.fillText("- CLICK TO START -", canvas.width / 2, canvas.height / 2 + 50);
            }
            ctx.restore();
        }

        function drawObjects() {
            obstacles.forEach(obstacle => {
                const drawX = Math.floor(obstacle.x);
                const drawY = Math.floor(obstacle.y);
                ctx.save();
                if (obstacle.isBlownAway) {
                    ctx.translate(drawX + obstacle.width / 2, drawY + obstacle.height / 2);
                    ctx.rotate(obstacle.rotation);
                    ctx.translate(-(drawX + obstacle.width / 2), -(drawY + obstacle.height / 2));
                }
                if (obstacle.isTall && obstacle2Img.complete) ctx.drawImage(obstacle2Img, drawX, drawY, 64, 128);
                else if (!obstacle.isTall && obstacle1Img.complete) ctx.drawImage(obstacle1Img, drawX, drawY, 64, 64);
                else {
                    ctx.fillStyle = '#e68161';
                    ctx.fillRect(drawX, drawY, obstacle.width, obstacle.height);
                }
                ctx.restore();
            });

            flyingObstacles.forEach(bird => {
                const drawX = Math.floor(bird.x);
                const drawY = Math.floor(bird.y);
                const birdImg = Math.floor(bird.wingAnimation) % 2 === 0 ? bird1Img : bird2Img;
                if (birdImg.complete) ctx.drawImage(birdImg, drawX, drawY, 59, 52);
            });

            coins.forEach(coin => {
                const drawX = Math.floor(coin.x);
                const drawY = Math.floor(coin.y);
                const frameIndex = Math.floor(coin.rotation / (Math.PI / 2)) % 4;
                if (coinImgs[frameIndex] && coinImgs[frameIndex].complete) {
                    ctx.drawImage(coinImgs[frameIndex], drawX, drawY, 48, 48);
                } else {
                    ctx.drawImage(coinImg, drawX, drawY, 48, 48);
                }
            });

            hearts.forEach(heart => {
                const drawX = Math.floor(heart.x);
                const drawY = Math.floor(heart.y);
                const pulse = 1 + Math.sin(heart.pulse) * 0.1;
                ctx.save();
                ctx.translate(drawX + 18.5, drawY + 15.5);
                ctx.scale(pulse, pulse);
                if (heartItemImg.complete) ctx.drawImage(heartItemImg, -18.5, -15.5, 37, 31);
                ctx.restore();
            });
        }

        function updateBackground() {
            const currentSpeed = (gameState === 'TITLE') ? 2 : gameSpeed;
            if (bgSkyImg.complete) {
                const skyScale = canvas.height / bgSkyImg.height;
                const skyScaledWidth = Math.ceil(bgSkyImg.width * skyScale);
                bgSkyOffset -= currentSpeed * 0.11;
                if (bgSkyOffset <= -skyScaledWidth) bgSkyOffset += skyScaledWidth;
            }
            if (bgGroundImg.complete) {
                const scale = canvas.height / bgGroundImg.height;
                const scaledWidth = Math.ceil(bgGroundImg.width * scale);
                bgGroundOffset -= currentSpeed * 0.5;
                if (bgGroundOffset <= -scaledWidth) bgGroundOffset += scaledWidth;
            }
        }

        function updateClouds() {
            const currentSpeed = (gameState === 'TITLE') ? 2 : gameSpeed;
            clouds.forEach(cloud => {
                cloud.x -= cloud.speed * currentSpeed;
                if (cloud.x + cloud.width < 0) {
                    cloud.x = canvas.width + cloud.width;
                    cloud.y = Math.random() * 100 + 20;
                }
            });
        }


        function updateGame() {
            if (gamePaused) return;

            if (player.x < 250) player.x += 1;

            // æ½œã‚ŠçŠ¶æ…‹ã®å‡¦ç†
            if (player.isDiving) {
                player.diveTimer--;

                if (player.diveTimer <= 0) {
                    // ãƒ€ã‚¤ãƒ–æ™‚é–“åˆ‡ã‚Œ -> ãã®ã¾ã¾ç«‹ã¡ä¸ŠãŒã‚‹ (å¼·åˆ¶)
                    player.isDiving = false;
                    // ã“ã“ã§ã®å¼·åˆ¶åº§æ¨™ãƒªã‚»ãƒƒãƒˆã¯å‰Šé™¤ã—ã€ç‰©ç†æ¼”ç®—ã«ä»»ã›ã‚‹(éšœå®³ç‰©ã®ä¸Šãªã‚‰ãã®ã¾ã¾)
                    // player.y = player.groundY; 
                }
            }

            // é‡åŠ›ã¯å¸¸ã«é©ç”¨ (æ½œã‚Šä¸­ã§ã‚‚éšœå®³ç‰©ã‹ã‚‰é™ã‚ŠãŸã‚‰è½ã¡ã‚‹)
            player.dy += player.gravity;
            player.y += player.dy;



            let onObstacle = false;
            // ç€åœ°åˆ¤å®š (æ½œã‚Šä¸­ã§ã‚‚éšœå®³ç‰©ã®ä¸Šã«ã¯ä¹—ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹)
            if (player.dy >= 0) {
                for (let obstacle of obstacles) {
                    const playerBottom = player.y + player.height;
                    const obstacleTop = obstacle.y;
                    const playerCenterX = player.x + player.width / 2;
                    // ç€åœ°åˆ¤å®šï¼ˆç”˜ã‚ï¼‰
                    if (playerCenterX > obstacle.x - 10 &&
                        playerCenterX < obstacle.x + obstacle.width + 10 &&
                        playerBottom >= obstacleTop - 10 &&
                        playerBottom <= obstacleTop + 10) {
                        player.y = obstacleTop - player.height;
                        player.dy = 0;
                        player.isJumping = false;
                        player.canDoubleJump = false;
                        onObstacle = true;
                        break;
                    }
                }
            }
            if (!onObstacle && player.y >= player.groundY) {
                player.y = player.groundY;
                player.dy = 0;
                player.isJumping = false;
                player.canDoubleJump = false;
            }
            // æ½œã‚Šä¸­ã¯ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®šï¼ˆç©´è½ä¸‹ãªã©ï¼‰ã‚‚ç„¡åŠ¹ã«ã™ã‚‹ã‹è¦ä»¶æ¬¡ç¬¬ã ãŒã€
            // ä»Šå›ã¯ç©´ã¯ãªã„ã®ã§å·¦ç«¯ã«è¿½ã„ã‚„ã‚‰ã‚Œãªã„é™ã‚ŠOK
            if (player.x + player.width < 0) {
                lives = 0;
                updateLivesDisplay();
                endGame();
            }

            if (isSuperMode) {
                superModeTimer--;
                if (superModeTimer <= 0) {
                    isSuperMode = false;
                    gameSpeed = baseSpeed;
                    comboCoins = 0;
                }
            }

            const speedMultiplier = 0.5;

            obstacleTimer++;
            if (obstacleTimer > nextObstacleInterval) {
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ãƒ©ãƒ³ãƒ€ãƒ 
                let nextIsTall = Math.random() < 0.2;

                // 3å›é€£ç¶šãƒã‚§ãƒƒã‚¯
                if (isSuperMode && lastObstacleType) {
                    if (consecutiveCount >= 2) {
                        // 2å›ä»¥ä¸ŠåŒã˜ãªã‚‰æ¬¡ã¯å¼·åˆ¶çš„ã«é€†ã«å¤‰æ›´ï¼ˆã“ã‚Œã§3å›é€£ç¶šã«ã¯ãªã‚‹ãŒ4å›ç›®ã«ã¯ãªã‚‰ãªã„ã€ã‚ã‚‹ã„ã¯3å›ç›®ã§å¤‰ãˆã‚‹ãªã‚‰ >=2 ã§åˆ¤å®šã—ã¦å¤‰ãˆã‚‹ï¼‰
                        // "ï¼“æšä»¥ä¸ŠåŒã˜ã‚‚ã®ãŒå‡ºãªã„ã‚ˆã†ã«" -> 2å›ç¶šã„ãŸã‚‰ã€3å›ç›®ã¯å¤‰ãˆã‚‹
                        nextIsTall = (lastObstacleType === 'small');
                        consecutiveCount = 0;
                    } else {
                        // åŒã˜ã‚¿ã‚¤ãƒ—ãŒç¶šã„ãŸã‚‰ã‚«ã‚¦ãƒ³ãƒˆã‚¢ãƒƒãƒ—ã€é•ã£ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
                        const currentType = nextIsTall ? 'tall' : 'small';
                        if (currentType === lastObstacleType) {
                            consecutiveCount++;
                        } else {
                            consecutiveCount = 1; // æ–°ã—ã„ã‚¿ã‚¤ãƒ—ãŒ1å›ç›®
                        }
                    }
                } else {
                    // ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¢ãƒ¼ãƒ‰ä»¥å¤–ã‚„åˆå›
                    const currentType = nextIsTall ? 'tall' : 'small';
                    if (currentType === lastObstacleType) consecutiveCount++;
                    else consecutiveCount = 1;
                }

                lastObstacleType = nextIsTall ? 'tall' : 'small';

                const obstacleHeight = nextIsTall ? 128 : 64;
                const obstacleY = (player.groundY + player.height) - obstacleHeight;
                obstacles.push({
                    x: canvas.width, y: obstacleY, width: 64, height: obstacleHeight,
                    isTall: nextIsTall, isBlownAway: false, rotation: 0
                });
                obstacleTimer = 0;
                // ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¢ãƒ¼ãƒ‰ä¸­ï¼ˆã‹ã¤æ®‹ã‚Š2ç§’ä»¥ä¸Šï¼‰ã¯åœ°é¢ãŒåŸ‹ã¾ã‚‹ãã‚‰ã„å¤§é‡å‡ºç¾
                // æ®‹ã‚Š120ãƒ•ãƒ¬ãƒ¼ãƒ (=2ç§’)ã‚’åˆ‡ã£ãŸã‚‰é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã™
                if (isSuperMode && superModeTimer > 120) {
                    // ä»¥å‰ã®ã€Œæ•·ãè©°ã‚ã‚‹ã€è¨­å®šã«æˆ»ã™
                    nextObstacleInterval = Math.random() * (15 - 12) + 12;
                } else {
                    nextObstacleInterval = Math.random() * (150 - 80) + 80;
                }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                if (obstacle.isBlownAway) {
                    obstacle.x += 10; obstacle.y -= 15; obstacle.rotation += 0.5;
                } else {
                    obstacle.x -= gameSpeed * speedMultiplier;
                }

                // è¡çªåˆ¤å®š
                // éšœå®³ç‰©ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ç„¡ã— (å£åˆ¤å®šã¯checkCollisionã§è¡Œã†)

                // ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¢ãƒ¼ãƒ‰ä½“å½“ãŸã‚Š
                if (isSuperMode && !obstacle.isBlownAway) {
                    if (player.x < obstacle.x + obstacle.width &&
                        player.x + player.width > obstacle.x &&
                        player.y < obstacle.y + obstacle.height &&
                        player.y + player.height > obstacle.y) {
                        obstacle.isBlownAway = true;
                        // ã‚¹ã‚³ã‚¢åŠ ç®—ãªã©
                    }
                }

                if (obstacle.x + obstacle.width < 0 || obstacle.y < -200) {
                    obstacles.splice(i, 1);
                    if (!obstacle.isBlownAway) {
                        score += 10;
                        if (score % 100 === 0 && gameSpeed < 8 && !isSuperMode) gameSpeed += 0.3;
                    }
                }
            }

            flyingObstacleTimer++;
            // ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¢ãƒ¼ãƒ‰ä¸­ã‹ã¤æ®‹ã‚Š2ç§’ä»¥ä¸Šãªã‚‰é³¥ã‚‚å¤§é‡å‡ºç¾
            const birdInterval = (isSuperMode && superModeTimer > 120) ? 25 : 100;

            if (flyingObstacleTimer > birdInterval) {
                // ã‚¹ãƒ”ãƒ¼ãƒ‰ã®å€‹ä½“å·®ã‚’æ±ºå®šï¼ˆé…ã„ã€æ™®é€šã€æ—©ã„ï¼‰
                // å¸¸ã«éšœå®³ç‰©(1.0)ã‚ˆã‚Šæ—©ãã—ãªã„ã¨å¾Œé€€ã—ã¦è¦‹ãˆã‚‹ãŸã‚ã€æœ€å°å€¤ã‚’1.1ä»¥ä¸Šã«è¨­å®š
                const speedType = Math.random();
                let speedFactor = 1.3; // æ™®é€š
                if (speedType < 0.33) speedFactor = 1.1; // å°‘ã—é…ã„ï¼ˆã§ã‚‚åœ°é¢ã‚ˆã‚Šã¯æ—©ã„ï¼‰
                else if (speedType > 0.66) speedFactor = 1.8; // æ—©ã„

                flyingObstacles.push({
                    x: canvas.width, y: 100 + Math.random() * 150, width: 59, height: 52,
                    wingAnimation: 0, isBlownAway: false, rotation: 0,
                    speedFactor: speedFactor // å€‹ä½“å·®ã‚¹ãƒ”ãƒ¼ãƒ‰
                });
                flyingObstacleTimer = 0;
            }

            for (let i = flyingObstacles.length - 1; i >= 0; i--) {
                const bird = flyingObstacles[i];
                if (bird.isBlownAway) {
                    bird.x += 15; bird.y -= 10; bird.rotation += 0.8;
                } else {
                    // å€‹åˆ¥ã®ã‚¹ãƒ”ãƒ¼ãƒ‰ä¿‚æ•°ã‚’ä½¿ç”¨
                    bird.x -= (gameSpeed * speedMultiplier) * bird.speedFactor;
                    bird.wingAnimation += 0.2;
                }
                if (bird.x + bird.width < 0 || bird.y < -200) {
                    flyingObstacles.splice(i, 1);
                    if (!bird.isBlownAway) score += 15;
                }
            }

            coinTimer++;
            if (coinTimer > 120) {
                coins.push({ x: canvas.width, y: 150 + Math.random() * 150, size: 48, rotation: 0 });
                coinTimer = 0;
            }

            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.x -= gameSpeed * speedMultiplier;
                coin.rotation += 0.1;

                if (!player.isDiving &&
                    player.x < coin.x + coin.size && player.x + player.width > coin.x &&
                    player.y < coin.y + coin.size && player.y + player.height > coin.y) {

                    coins.splice(i, 1);
                    score += 20;

                    if (!isSuperMode) {
                        comboCoins++;
                        if (comboCoins >= 5) {
                            isSuperMode = true;
                            superModeTimer = 600;
                            baseSpeed = gameSpeed;
                            gameSpeed *= 3;
                            comboCoins = 0;
                        }
                    }
                    continue;
                }

                if (coin.x + coin.size < 0) {
                    coins.splice(i, 1);
                }
            }

            heartTimer++;
            if (heartTimer > 300) {
                hearts.push({ x: canvas.width, y: 150 + Math.random() * 150, size: 37, pulse: 0 });
                heartTimer = 0;
            }

            for (let i = hearts.length - 1; i >= 0; i--) {
                const heart = hearts[i];
                heart.x -= gameSpeed * speedMultiplier;
                heart.pulse += 0.1;

                if (!player.isDiving &&
                    player.x < heart.x + heart.size && player.x + player.width > heart.x &&
                    player.y < heart.y + heart.size && player.y + player.height > heart.y) {

                    hearts.splice(i, 1);
                    if (lives < 3) { lives++; updateLivesDisplay(); }
                    else { score += 50; }
                    continue;
                }

                if (heart.x + heart.size < 0) {
                    hearts.splice(i, 1);
                }
            }

            if (invincibleTimer > 0) invincibleTimer--;
        }

        // è¡çªåˆ¤å®š
        function checkCollision() {
            for (let obstacle of obstacles) {
                // å£ãƒ’ãƒƒãƒˆåˆ¤å®šï¼ˆå³ã—ã‚ï¼‰
                if (!player.isDiving && !obstacle.isBlownAway &&
                    player.x + 5 < obstacle.x + obstacle.width - 5 &&
                    player.x + player.width - 5 > obstacle.x + 5 &&
                    player.y + 20 < obstacle.y + obstacle.height - 5 &&
                    player.y + player.height - 5 > obstacle.y + 5) {

                    if (isSuperMode) {
                        obstacle.isBlownAway = true; score += 50; continue;
                    }
                    // æ½œã‚Šä¸­ã¯ç‰©ç†å£ã‚‚ã‚¹ã‚­ãƒƒãƒ—
                    if (!player.isDiving) {
                        // åˆ¤å®š: ã€Œæ¨ªã‹ã‚‰å½“ãŸã£ãŸ(é€šå¸¸ç§»å‹•)ã€ã‹ã€Œä¸­ã‹ã‚‰å‡ºãŸ(æ½œã‚Šè§£é™¤)ã€ã‹
                        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å·¦ç«¯ãŒã€éšœå®³ç‰©ã®å·¦ç«¯ã‚ˆã‚Šå¥¥(å³)ã«ã‚ã‚‹ãªã‚‰ã€Œä¸­ã€ã¨ã¿ãªã™
                        const isInside = (player.x > obstacle.x + 5);

                        if (isInside) {
                            // ä¸­ã‹ã‚‰å‡ºã¦ã—ã¾ã£ãŸ -> ãƒ€ãƒ¡ãƒ¼ã‚¸ & å‰ã¸å¼¾ã
                            lives--;
                            updateLivesDisplay();
                            if (lives <= 0) endGame();
                            invincibleTimer = 90;
                            player.x = obstacle.x + obstacle.width + 10;
                        } else {
                            // å¤–(å·¦)ã‹ã‚‰å½“ãŸã£ãŸ -> å£ã¨ã—ã¦æ­¢ã‚ã‚‹ (ãƒ€ãƒ¡ãƒ¼ã‚¸ãªã—)
                            player.x = obstacle.x - player.width + 5;
                        }
                    }
                }
            }

            // Birdç­‰ã®ãƒã‚§ãƒƒã‚¯...


            if (invincibleTimer > 0) return false;
            for (let bird of flyingObstacles) {
                if (!player.isDiving && !bird.isBlownAway &&
                    player.x + 10 < bird.x + bird.width - 10 &&
                    player.x + player.width - 10 > bird.x + 10 &&
                    player.y + 10 < bird.y + bird.height - 10 &&
                    player.y + player.height - 10 > bird.y + 10) {

                    if (isSuperMode) {
                        bird.isBlownAway = true; score += 50; continue;
                    }
                    handleCollision();
                    return true;
                }
            }
            return false;
        }

        function handleCollision() {
            lives--;
            updateLivesDisplay();
            if (lives <= 0) endGame();
            // é³¥ãªã©ã¯å¼¾ãé£›ã°ã•ãªã„ (éšœå®³ç‰©ã¯ updateGame ã§å€‹åˆ¥ã«å‡¦ç†æ¸ˆã¿)
            invincibleTimer = 90;
        }

        function updateLivesDisplay() {
            livesElement.textContent = 'â¤ï¸'.repeat(lives) + 'ğŸ–¤'.repeat(3 - lives);
        }

        function togglePause() {
            if (gameState !== 'PLAYING' || gameOverScreen.classList.contains('show')) return;
            gamePaused = !gamePaused;
            pauseBtn.textContent = gamePaused ? 'å†é–‹' : 'ä¸€æ™‚åœæ­¢';
        }

        function startGame() {
            gameState = 'PLAYING';
            score = 0;
            lives = 3;
            gameSpeed = 6;
            baseSpeed = 6;
            frameCount = 0;

            obstacles.length = 0;
            obstacleTimer = 0;
            flyingObstacles.length = 0;
            flyingObstacleTimer = 0;
            coins.length = 0;
            coinTimer = 0;
            hearts.length = 0;
            heartTimer = 0;
            invincibleTimer = 0;
            comboCoins = 0;
            isSuperMode = false;

            player.x = 250;
            player.y = player.groundY;
            player.dy = 0;
            player.isJumping = false;
            gamePaused = false;

            scoreElement.textContent = score;
            updateLivesDisplay();

            gameOverScreen.classList.remove('show');
            controlsPanel.classList.add('active');
            pauseBtn.disabled = false;
            pauseBtn.textContent = 'ä¸€æ™‚åœæ­¢';
        }

        function endGame() {
            gameState = 'GAMEOVER';
            saveScoreToHistory(score);

            const isNewRecord = score > highScore;
            if (isNewRecord) {
                highScore = score;
                highScoreElement.textContent = highScore;
                localStorage.setItem('jumpGameHighScore', highScore.toString());
                newRecordElement.style.display = 'block';
            } else {
                newRecordElement.style.display = 'none';
            }

            checkGalleryUnlocks(score);

            finalScoreElement.textContent = `ã‚¹ã‚³ã‚¢: ${score}`;
            gameOverScreen.classList.add('show');
            pauseBtn.disabled = true;
        }

        function restartGame() {
            gameOverScreen.classList.remove('show');
            startGame();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'TITLE') {
                drawTitleScreen();
                requestAnimationFrame(draw);
                return;
            }

            if (gameState === 'GAMEOVER') {
                drawClouds();
                drawGround();
                drawObjects();
                drawPlayer();
                drawUI();
                requestAnimationFrame(draw);
                return;
            }

            if (gameState === 'PLAYING') {
                if (!gamePaused) {
                    frameCount++;
                    updateBackground();
                    updateClouds();
                    updateGame();
                    if (frameCount % 10 === 0) {
                        score++;
                        scoreElement.textContent = score;
                        if (score % 200 === 0 && gameSpeed < 10) gameSpeed += 0.5;
                    }
                    checkCollision();
                }

                drawClouds();
                drawGround();
                drawObjects();
                drawPlayer();
                drawUI();

                if (gamePaused) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.font = "bold 40px 'Mochiy Pop One', sans-serif";
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.fillText('ä¸€æ™‚åœæ­¢ä¸­', canvas.width / 2, canvas.height / 2);
                }

                requestAnimationFrame(draw);
            }
        }

        function saveScoreToHistory(score) {
            let history = JSON.parse(localStorage.getItem('jumpGameScoreHistory') || '[]');
            history.push({ score: score, date: new Date().toLocaleString('ja-JP') });
            history.sort((a, b) => b.score - a.score);
            history = history.slice(0, 10);
            localStorage.setItem('jumpGameScoreHistory', JSON.stringify(history));
        }
        function toggleRanking() {
            const screen = document.getElementById('rankingScreen');
            if (screen.style.display === 'none') {
                screen.style.display = 'block';
                displayRanking();
            } else {
                screen.style.display = 'none';
            }
        }
        function displayRanking() {
            const history = JSON.parse(localStorage.getItem('jumpGameScoreHistory') || '[]');
            const list = document.getElementById('rankingList');
            if (history.length === 0) { list.innerHTML = '<p>ã¾ã ã‚¹ã‚³ã‚¢ãŒã‚ã‚Šã¾ã›ã‚“</p>'; return; }
            let html = '<ol style="padding-left: 20px;">';
            history.forEach((entry, i) => {
                const medal = i === 0 ? 'ğŸ¥‡' : i === 1 ? 'ğŸ¥ˆ' : i === 2 ? 'ğŸ¥‰' : '';
                html += `<li>${medal} ${entry.score}ç‚¹ <span style="font-size:0.8em; color:#aaa;">${entry.date}</span></li>`;
            });
            list.innerHTML = html + '</ol>';
        }
        const galleryItems = [
            { id: 1, requiredScore: 500, title: 'ã‚¤ãƒ©ã‚¹ãƒˆ #1', unlocked: false, filename: 'illust_sca_500.png' },
            { id: 2, requiredScore: 1000, title: 'ã‚¤ãƒ©ã‚¹ãƒˆ #2', unlocked: false, filename: 'illust_sca_1000.png' },
            { id: 3, requiredScore: 2000, title: 'ã‚¤ãƒ©ã‚¹ãƒˆ #3', unlocked: false, filename: 'illust_sca_2000.png' },
            { id: 4, requiredScore: 3000, title: 'ã‚¤ãƒ©ã‚¹ãƒˆ #4', unlocked: false, filename: 'illust_sca_3000.png' },
            { id: 5, requiredScore: 5000, title: 'ã‚¤ãƒ©ã‚¹ãƒˆ #5', unlocked: false, filename: 'illust_sca_5000.png' }
        ];
        function loadGalleryProgress() {
            const unlocked = JSON.parse(localStorage.getItem('jumpGameGalleryUnlocked') || '[]');
            galleryItems.forEach(item => { item.unlocked = unlocked.includes(item.id); });
        }
        function checkGalleryUnlocks(score) {
            const unlocked = JSON.parse(localStorage.getItem('jumpGameGalleryUnlocked') || '[]');
            let isUpdated = false;
            galleryItems.forEach(item => {
                if (score >= item.requiredScore && !unlocked.includes(item.id)) {
                    unlocked.push(item.id);
                    isUpdated = true;
                }
            });
            if (isUpdated) localStorage.setItem('jumpGameGalleryUnlocked', JSON.stringify(unlocked));
        }
        function toggleGallery() {
            const screen = document.getElementById('galleryScreen');
            if (screen.style.display === 'none') {
                screen.style.display = 'block';
                displayGallery();
            } else {
                screen.style.display = 'none';
            }
        }
        function displayGallery() {
            loadGalleryProgress();
            const grid = document.getElementById('galleryGrid');
            let html = '';
            galleryItems.forEach(item => {
                if (item.unlocked) {
                    html += `<div><img src="${item.filename}" style="width:100%; border-radius:8px;"><p>${item.title}</p></div>`;
                } else {
                    html += `<div style="opacity:0.5; border:1px solid #555; padding:20px;">ğŸ”’ ${item.requiredScore}ç‚¹</div>`;
                }
            });
            grid.innerHTML = html;
        }

        function resizeCanvas() {
            canvas.width = 800; canvas.height = 400;
            player.groundY = canvas.height - 95;
            player.y = player.groundY;
        }
        resizeCanvas();
        loadGalleryProgress();

        draw(); 
    </script>
</body>

</html>